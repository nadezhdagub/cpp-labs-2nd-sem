Лабораторные работы по программированию на С++ (2-й семестр)



# 1 Векторы <br>
Необходимо выполнить все задания.<br>
Работа должна быть выполнена в виде 1 исполняемого файла, принимающего параметры следующим образом:<br>
**$ ./lab number [args]**<br>
**number** представляет собой номер пункта, например, 1 или 2. В качестве args передаются дополнительные параметры, зависящие от пункта.<br>
1. Напишите алгоритм сортировки (любой простейший) коллекции целых чисел, полученных из стандартного ввода, так, чтобы:<br>
<br>
(a) сортировка вектора проводилась с использованием оператора operator [];<br>
(b) сортировка вектора проводилась с использованием метода **std::vector<>::at()** .<br>
(c) сортировка односвязного списка осуществлялась при помощи итераторов [Мар, разд. 16.3.1].<br>
<br>
Окончанием ввода необходимо считать состояние **End Of File**(EOF, конец файла).<br>
Программа должна запускаться с дополнительным параметром, в зависимости от значения которого, сортировка производится по возрастанию или убыванию:<br>
<br>
**ascending** по возрастанию;<br>
**descending** по убыванию.<br>
<br>
Выведите на стандартный вывод отсортированные коллекции, разделяя элементы пробелами. Коллекция, отсортированная каждым видом доступа, должна быть выведена на отдельной строке. Например,<br>
**$ cat data**<br>
**4 3 2 1**<br>
**$ ./lab 1 ascending < data**<br>
**1 2 3 4**<br>
**1 2 3 4**<br>
**1 2 3 4**<br>
2. Прочитайте во встроенный массив C содержимое текстового файла, имя которого передано в параметре. Скопируйте данные в вектор одной строкой кода (без циклов и алгоритмов Standard Template Library (STL)).
Выведите на стандартный вывод содержимое вектора.<br>
3. Напишите программу, сохраняющую в векторе целые числа, полученные из стандартного ввода
(окончанием ввода является число 0). Используя итераторы, удалите все элементы, которые делятся на 2 (не используя алгоритмы STL), если последнее число 1. Если последнее число 2, добавьте после каждого числа, которое делится на 3, три единицы, также используя итераторы. Все изменения должны осуществляться при помощи итераторов и без использования индексов.<br>
Выведите на стандартный вывод полученную после преобразований коллекцию чисел, разделяя числа пробелом.
4. Напишите функцию **void fillRandom(double * array, int size)**, заполняющую массив случайными значениями в интервале от −1.0 до +1.0. Заполните с помощью заданной функции вектор заданного размера и отсортируйте его содержимое (с помощью любого разработанного ранее алгоритма, модифицированного для сортировки как целых, так и действительных чисел).
Выведите на стандартный вывод исходную и отсортированную коллекции на отдельных строках, разделяя элементы пробелами.<br>
Программа должна запускаться с 2 дополнительными параметрами:<br>
<br>
•	направление сортировки (**ascending** или **descending**);<br>
•	размер вектора.<br>
<br>
Например,<br>
**$./lab  4  ascending  3 **<br>
**0.5  0.8  0.4**<br>
**0.4  0.5  0.8**<br>
# 2 Текст
Разработать программу, которая должна сделать следующее:<br>
1. Прочитать текст со стандартного ввода, который может содержать:<br>
<br>
(a) Слова — состоят из латинских строчных и заглавных букв, а также дефиса «-», длина слова должна быть не более 20 символов.<br>
(b) Слова могут заканчиваться дефисом, но не могут с него начинаться.<br>
(c) Знаки препинания — «.», «,», «!», «?», «:», «;», «---» (3 дефиса, эквивалент тире). Знаки препинания не могут идти друг за другом, за исключением тире: перед тире может встречаться запятая. Допускается обработка и других знаков препинания в соответствии с тем, как их понимают настройки пользователя.<br>
(d) Числа, состоящие из цифр и десятичного разделителя, а также опционального знака числа («+» и «-»), разделение групп цифр не используется, длина числа — не более 20 символов.<br>
(e) Пробельные символы — пробел, табуляция, символ новой строки.<br>
(f) Текст не может начинаться с пунктуации.<br>
<br>
2. Отформатировать текст следующим образом:<br>
<br>
(a) Не должно быть пробельных символов, отличных от пробела.<br>
(b) Не должно идти подряд более одного пробела.<br>
(c) Между словом и знаком препинания не должно быть пробела, за исключением тире, которое выделяется пробелами с обеих сторон.<br>
(d) После знака препинания всегда должен идти пробел.<br>
(e) Не допускается перенос тире на следующую строку.<br>
<br>
3. Преобразовать полученный текст в набор строк, каждая из которых содержит целое количество слов и чисел (каждый элемент должен целиком находиться в строке) и ее длина не превышает число символов, задаваемых параметром. При этом каждая строка должна содержать максимальное число слов, не должна заканчиваться пробельными символами и начинаться со знаков препинания.<br>
4. Вывести полученный набор строк на стандартный вывод.<br>
Программа должна принимать необязательный аргумент **--line-width** с параметром, указывающим длину строки в символах. Если параметр не указан, длина строки принимается в 40 символов. Таким образом, программа может быть запущена:<br>
**$ ./lab --line-width 70**<br>
Это дает длину строки в 70 символов. Или так:<br>
**$ ./lab**<br>
Что дает значение по умолчанию в 40 символов.<br>
Всю дополнительную информацию, в частности, десятичный разделитель, необходимо получить из настроек пользователя при помощи стандартной библиотеки1.<br>
# 3 Последовательности<br>
Необходимо выполнить все задания.<br>
Как и задание 1, это задание должно быть выполнено в виде консольной программы, принимающей в качестве единственного параметра номер пункта задания.<br>
#### 1
Ниже приведен интерфейс класса очереди с приоритетами, который функционирует следующим образом:<br>
1. В очередь могут быть добавлены элементы, каждому элементу при добавлении присваивается один из трех уровней приоритета (**low**, **normal**, **high**).<br>
2. Элементы из очереди извлекаются в соответствии с их приоритетами (сначала извлекаются элементы с приоритетом **high**, потом **normal**, потом **low**), элементы с одинаковыми приоритетами извлекаются из очереди в порядки их поступления.<br>
3. В очереди также может происходить операция акселерации –– все элементы с приоритетом **low**, находящиеся в момент акселерации в очереди, увеличивают свой приоритет до **high** и «обгоняют» элементы с приоритетом **normal**.<br>
Ниже приведен интерфейс этого класса:<br>
1 **typedef enum**<br>
2 **{**<br>
3 **LOW,**<br>
4 **NORMAL,**<br>
5 **HIGH**<br>
6 **} ElementPriority;**<br>
7<br>
8 **typedef struct**<br>
9 **{**<br>
10 **std::string name;**<br>
11 **} QueueElement;**<br>
12<br>
13 **class QueueWithPriority**<br>
14 **{**<br>
15 **QueueWithPriority();**<br>
16<br>
17 **~QueueWithPriority();**<br>
18<br>
19 **void PutElementToQueue(const QueueElement & element,**<br>
20 **ElementPriority priority);**<br>
21<br>
22 **QueueElement GetElementFromQueue();**<br>
23<br>
24 **void Accelerate();**<br>
25 **};**<br>
1. Переработайте класс так, чтобы он мог обрабатывать элементы произвольного типа.<br>
2. Исправьте ошибки в интерфейсе, обеспечив безопасный интерфейс для применения в большом промышленном проекте.<br>
3. Реализуйте исправленный класс, используя **std::list<>** или **std::deque<>**. Объясните выбор. <br>
4. Реализуйте программу, обрабатывающую очередь из строк по командам, принимаемым со стандартного ввода. Каждая строка содержит ровно одну команду. Должны поддерживаться следующие
команды:<br>
•	**add <priority> <data>**<br>
Добавление элемента в очередь с приоритетом **<priority>** (**low**, **normal** или **high**).<br>
•	**get**<br>
Получение очередного элемента в очереди в соответствии с приоритетом, в стандартный вывод печатаются данные элемента. В случае, если очередь пуста, выводится строка **<EMPTY>**.<br>
•	**Accelerate**<br>
Изменение приоритета элементов очереди.<br>
В случае получения неподдерживаемой или неправильно сформированной команды в стандартный вывод печатается **<INVALID COMMAND>**.
#### 2
Разработайте программу, которая:<br>
1. Заполняет **std::list< int >** значениями от 1 до 20 со стандартного ввода, список может содержать от 0 до 20 значений.<br>
2. Выводит содержимое списка в следующем порядке: первый элемент, последний элемент, второй элемент, предпоследний элемент, третий элемент и т.д.<br>
3. В случае получения некорректных данных программа должна выводить сообщение об ошибке в стандартный поток ошибок и завершаться с кодом 1.<br>
Например если список содержит:<br>
**1 2 3 4 5 6 7 8**<br>
то вывод будет иметь вид<br>
**1 8 2 7 3 6 4 5**<br>
Подсказка: можно использовать рекурсию и двунаправленные итераторы.<br>
# 4 Итераторы<br>
Выполните все задания в виде программы, принимающей в качестве первого параметра номер пункта:<br>
#### 1<br>
Напишите программу-«телефонную книжку», состоящую из 2-х компонентов:<br>
1. Компонент-книжка.<br>
Записи (имя и телефон) должны хранится в каком-либо контейнере из STL.<br>
Программа должна поддерживать следующие операции:<br>
<br>
•	Просмотр текущей записи.<br>
•	Переход к следующей записи.<br>
•	Переход к предыдущей записи.<br>
•	Вставка записи перед/после просматриваемой.<br>
•	Замена просматриваемой записи.<br>
•	Вставка записи в конец базы данных.<br>
•	Переход вперед/назад через n записей.<br>
<br>
Необходимо учесть, что клиентскому коду может быть необходимо иметь ссылки на разные записи в книжке одновременно.<br>
Помните, что после вставки и удаления элемента итераторы могут стать недействительными. Телефон представляется в виде последовательности цифр без разделителей.<br>
2. Пользовательский интерфейс, принимающий команды со стандартного ввода по одной на строке и выводящий результаты на стандартный вывод. Должны поддерживаться следующие команды:<br>
•	**add number "name"**
Добавление записи в конец. Кавычки не являются частью имени. Требуется учесть, что имя может содержать кавычки и обратную черту, (предваренные обратной косой чертой, как в литералах C++ [Мар, табл. 3.2]), но не может содержать новую строку (например, "Name\"Nick\"Surname").<br>
•	**store mark-name new-mark-name**
Сохраняет текущую позицию закладки с именем mark-name как новую закладку с именем new-mark-name. Имя содержит только символы английского алфавита, цифры и знак «минус». После запуска программы доступна 1 закладка с именем **current**.<br>
•	**insert before mark-name number "name"**<br>
Добавление записи перед закладкой **mark-name**.<br>
•	 **insert after mark-name number "name"**<br>
Добавление записи после закладки **mark-name**.<br>
•	**delete mark-name**<br>
Удаление записи, на которую указывает закладка mark-name. После удаления закладка указывает на следующий элемент.<br>
•	**show mark-name**<br>
Показ записи, на которую указывает закладка mark-name. Если записей нет (книжка пустая), выводится **<EMPTY>**. Вывод должен быть выполнен без служебных последовательностей, в частности, строка из примера команды **add** должна быть выведена как Name **"Nick"Surname**.<br>
•	**move mark-name steps**<br>
Перемещение закладки mark-name на steps элементов. Если steps положительно, то закладка перемещается вперед, иначе — назад. Также в качестве steps могут быть использованы ключевые слова first и last, означающие первую и последнюю запись соответственно. Если параметр steps не число и не зарезервированное ключевое слово, в стандартный вывод выводится сообщение <INVALID STEP>.
Работа пользовательского интерфейса заканчивается при наступлении EOF или ошибки ввода-вывода. В случае ошибки, код возврата должен быть равен 2.<br>
В случае получения неправильной команды необходимо вывести в стандартный вывод строку **<INVALID COMMAND>** и продолжить работу.
Если переданное имя закладки не существует в стандартный вывод выводится строка **<INVALID BOOKMARK>**.<br>
#### 2<br><br>
Реализуйте следующие классы:<br>
•	«Контейнер», который содержит значения факториала от 1! до 10!.<br>
Интерфейс класса должен включать в себя как минимум:<br>
<br>
– Конструктор по умолчанию.<br>
– Функцию получения итератора указывающего на первый элемент контейнера — **begin()**.<br>
– Функцию получения итератора указывающего на элемент, следующий за последним — **end()**.<br>
Доступ к элементам этого контейнера возможен только с помощью итераторов, возвращаемых функциями **begin()** и **end()**.<br>
Контейнер не должен хранить в памяти свои элементы, они должны вычисляться при обращении к ним через итератор.<br>
•	Класс итератора для перечисления элементов этого контейнера, объекты этого класса возвращаются функциями **begin()** и **end()**. Итератор должен быть двунаправленным. Итератор должен быть совместимым с STL.<br>
Требования категории итератора должны быть выполнены.<br>
•	Выведите содержимое «контейнера» в 2 строки в стандартный вывод: первая строка в прямом направлении, вторая — в обратном при помощи std:copy(). Необходимо помнить, что предотвратить применение std::reverse_iterator<> в клиентском коде невозможно.
# 5 Алгоритмы I<br>
Написать программу, которая выполняет следующие действия:<br>
1. Заполняет **std::vector< DataStruct > структурами DataStruct**, прочитанными со стандартного ввода. Каждая строка содержит последовательно **key1**, **key2** и **str**, разделенные запятыми, **str** продолжается до конца строки. **key1** и **key2** в диапазоне от −5 до +5.
2. Сортирует вектор следующим образом:<br>
<br>
(a) По возрастанию **key1**.<br>
(b) Если key1 одинаковые, то по возрастанию **key2**.<br>
(c) Если key1 и key2 одинаковые, то по возрастанию длины строки **str**.<br>
3. Выводит полученный вектор на печать.<br>
**DataStruct** определена следующим образом:<br>
1 **struct DataStruct**<br>
2 **{**<br>
3 **int key1;**<br>
4 **int key2;**<br>
5 **std::string str;**<br>
6 **};**<br>
# 6 Алгоритмы II<br>
Это задание должно быть выполнено в виде единой консольной программы. Выбор задания выполняется при помощи первого параметра при запуске.<br>
#### 1<br>
Выполнить:<br>
1. Чтение содержимого текстового файла, переданного через стандартный ввод.<br>
2. Выделение слов, словом считается последовательность символов, разделенных пробелами и/или знаками табуляции и/или символами новой строки.<br>
3. Вывод списка слов (по одному слову в строке), присутствующих в тексте без повторений (имеется в виду, что одно и то же слово может присутствовать в списке только один раз).<br>
#### 2
С помощью стандартных алгоритмов выполнить следующие действия:<br>
1. Заполнить контейнер геометрическими фигурами, прочитав их со стандартного ввода. Этот пункт должен быть выполнен отдельным действием, нельзя совмещать дальнейшие действия с чтением данных.<br>
2. Подсчитать общее количество вершин всех фигур (так треугольник добавляет к общему числу 3, квадрат 4 и т.д.).<br>
3. Подсчитать количество треугольников, квадратов и прямоугольников.<br>
4. Удалить все пятиугольники.<br>
5. На основании оставшихся данных создать **std::vector< Point >**, который содержит координаты одной из вершин (любой) каждой фигуры, т.е. первый элемент этого вектора содержит координаты одной из вершин первой фигуры, второй элемент этого вектора содержит координаты одной из вершин второй фигуры и т.д.<br>
6. Изменить контейнер так, чтобы он содержал в начале все треугольники, потом все квадраты, а потом прямоугольники.<br>
7. Вывести на стандартный вывод результаты работы в виде:<br>
**Vertices: 16**<br>
**Triangles: 1**<br>
**Squares: 1**<br>
**Rectangles: 2**<br>
**Points: (5;5) (10;10) (1;1)**<br>
**Shapes:**<br>
**3 (1;1) (2;2) (3;1)**<br>
**4 (10;10) (10;11) (11;11) (11;10)**<br>
**4 (5;5) (7;5) (7;6) (5;6)**<br>
Пример 1: Пример вывода для работы 6.2<br>
Геометрическая фигура задается следующей структурой:<br>
1 **struct Point**<br>
2 **{**<br><br>
3 **int x,y;**<br>
4 **};**<br>
5<br>
6 **using Shape = std::vector< Point >**;<br>
Каждая точка задается парой координат (x; y), фигуры указывается по одной на строке, первое число задает количество вершин, затем указываются точки-вершины:<br>
**3 (1;3) (23;3) (15;8)**<br>
Фигуры не содержат самопересечений, проверять это условие не требуется. В случае, если все точки фигуры совпадают, фигуру следует считать самым строгим вариантом такого многоугольника.
Подсказка: кроме алгоритмов рассмотренных в этой работе можно применять все средства описанные в предыдущих работах, включая алгоритмы сортировки.
# 7 Функторы I<br>
Разработать функтор, позволяющий собирать статистику о последовательности целых чисел. Функтор после обработки последовательности алгоритмом std::for_each должен предоставлять следующую статистику:<br>
1. Максимальное число в последовательности.<br>
2. Минимальное число в последовательности.<br>
3. Среднее чисел в последовательности.<br>
4. Количество положительных чисел.<br>
5. Количество отрицательных чисел.<br>
6. Сумму нечетных элементов последовательности.<br>
7. Сумму четных элементов последовательности.<br>
8. Совпадают ли первый и последний элементы последовательности.<br>
Проверить работу, написав программу, принимающую набор чисел со стандартного ввода и выводящую статистику в формате:<br>
**Max: 124**<br>
**Min: -784365**<br>
**Mean: 765,65**<br>
**Positive: 15**<br>
**Negative: 24**<br>
**Odd Sum: 123**<br>
**Even Sum: 87464**<br>
**First/Last Equal: no**<br>
Пример 2: Пример вывода для работы 7<br>
Если в списке нет значений, то необходимо вывести строку **«No Data»**.<br>
# 8 Функторы II <br>
Это задание должно быть выполнено в виде единой консольной программы. Выбор задания выполняется при помощи первого параметра при запуске.<br>
#### 1<br>
Используя только стандартные алгоритмы и функторы, умножить каждый элемент списка чисел с плавающей точкой на число �. Числа должны быть прочитаны со стандартного ввода, результаты выведены в стандартный вывод.<br>
#### 2
1. Реализовать иерархию геометрических фигур, состоящую из:<br>
(a) Класс **Shape**, содержащий:<br>
•	информацию о положении центра фигуры (координаты x и y);<br>
•	метод **isMoreLeft()**, позволяющий определить расположена ли данная фигура левее (определяется по положению центра) чем фигура, переданная в качестве аргумента;<br>
•	метод **isUpper**, позволяющий определить расположена ли данная фигура выше (определяется по положению центра) чем фигура, переданная в качестве аргумента;<br>
•	чисто виртуальную функцию рисования draw() (каждая фигура в реализации этой функции должна выводить в переданный поток свое название и положение центра).<br>
(b) Класс **Circle**, производный от класса **Shape**.<br>
(c) Класс **Triangle**, производный от класса **Shape**.<br>
(d) Класс **Square**, производный от класса **Shape**.<br>
2. Заполнить список указателей на различные фигуры, прочитав их со стандартного ввода.<br>
3. С помощью стандартных алгоритмов и адаптеров вывести все фигуры.<br>
4. С помощью стандартных алгоритмов и адаптеров отсортировать список по положению центра слева-направо (имеется в виду, что в начале списка должны идти фигуры находящиеся левее) и вывести результат фигуры.<br>
5. С помощью стандартных алгоритмов и адаптеров отсортировать список по положению центра справа-налево и вывести фигуры.<br>
6. С помощью стандартных алгоритмов и адаптеров отсортировать список по положению центра сверху-вниз и вывести фигуры.<br>
7. С помощью стандартных алгоритмов и адаптеров отсортировать список по положению центра снизу-вверх и выводит фигуры.<br>
Фигуры при вводе данных задаются по одной на строке, тип фигуры определяется ключевым словом <br>
(**CIRCLE**, **TRIANGLE** и **SQUARE**), после которого задаются координаты центра с скобках. Вывод различных списков отметить строками **«Original:»**, **«Left-Right:»**, **«Right-Left:»**, **«Top-Bottom:»** и **«Bottom-Top»**.<br>
Фигуры выводятся по одной на строку в том же формате, что и при вводе ()<br>
**CIRCLE (1;2)**<br>
**TRIANGLE (-5;10)**<br>
**SQUARE (15;5)**<br>
**CIRCLE (-3;-3)**<br>
Пример 3: Пример ввода для работы 8.2<br>
**Original:**<br>
**CIRCLE (1;2)**<br>
**TRIANGLE (-5;10)**<br>
**SQUARE (15;5)**<br>
**CIRCLE (-3;-3)**<br>
**Left-Right:**<br>
**TRIANGLE (-5;10)**<br>
**CIRCLE (-3;-3)**<br>
**CIRCLE (1;2)**<br>
**SQUARE (15;5)**<br>
**Right-Left:**<br>
**SQUARE (15;5)**<br>
**CIRCLE (1;2)**<br>
**CIRCLE (-3;-3)**<br>
**TRIANGLE (-5;10)**<br>
**Top-Bottom:**<br>
**CIRCLE (-3;-3)**<br>
**CIRCLE (1;2)**<br>
**9SQUARE (15;5)**<br>
**TRIANGLE (-5;10)**<br>
**Bottom-Top:**<br>
**TRIANGLE (-5;10)**<br>
**SQUARE (15;5)**<br>
**CIRCLE (1;2)**br>
**CIRCLE (-3;-3)**br>
Пример 4: Пример вывода для работы 8.2

